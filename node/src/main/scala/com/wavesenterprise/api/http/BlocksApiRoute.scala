package com.wavesenterprise.api.http

import akka.http.scaladsl.server.{Route, StandardRoute}
import com.wavesenterprise.account.Address
import com.wavesenterprise.api.ValidInt._
import com.wavesenterprise.api.http.ApiError.{BlockDoesNotExist, CustomValidationError, InvalidSignature, TooBigArrayAllocation}
import com.wavesenterprise.block.BlockHeader
import com.wavesenterprise.settings.ApiSettings
import com.wavesenterprise.state.{Blockchain, ByteStr}
import com.wavesenterprise.transaction._
import com.wavesenterprise.utils.Time
import monix.execution.schedulers.SchedulerService
import play.api.libs.json._

class BlocksApiRoute(val settings: ApiSettings, val time: Time, val blockchain: Blockchain, val nodeOwner: Address, val scheduler: SchedulerService)
    extends ApiRoute
    with TxApiFunctions {

  // todo: make this configurable and fix integration tests
  val MaxBlocksPerRequest = 100

  override lazy val route: Route =
    pathPrefix("blocks") {
      withAuth() {
        signature ~ first ~ last ~ lastHeaderOnly ~ at ~ atHeaderOnly ~ seqExt ~ seq ~ seqHeaderOnly ~ height ~ heightEncoded ~ child ~ address
      }
    }

  /**
    * GET /blocks/address/{address}/{from}/{to}
    *
    * Get list of blocks generated by specified address
    **/
  def address: Route =
    (path("address" / Segment / Segment / Segment) & get) {
      case (address, startStr, endStr) =>
        withExecutionContext(scheduler) {
          List(PositiveInt(startStr), PositiveInt(endStr)).processRoute {
            case Seq(start, end) =>
              if (end >= 0 && start >= 0 && end - start >= 0 && end - start < MaxBlocksPerRequest) {
                val blocks = JsArray(
                  (start to end)
                    .map { height =>
                      (blockchain.blockAt(height), height)
                    }
                    .collect {
                      case (Some(block), height) if block.signerData.generatorAddress.address == address =>
                        block.json() + ("height" -> Json.toJson(height))
                    })
                complete(blocks)
              } else complete(TooBigArrayAllocation)
          }
        }
    }

  /**
    * GET /blocks/child/{signature}
    *
    * Get successor of specified block by its signature
    **/
  def child: Route = (path("child" / Segment) & get) { encodedSignature =>
    withBlock(blockchain, encodedSignature) { block =>
      withExecutionContext(scheduler) {
        val childJson = for {
          h <- blockchain.heightOf(block.uniqueId)
          b <- blockchain.blockAt(h + 1)
        } yield b.json()

        complete(childJson.getOrElse[JsObject](Json.obj("status" -> "error", "details" -> "No child blocks")))
      }
    }
  }

  /**
    * GET /blocks/height/{signature}
    *
    * Height of a block by its signature
    **/
  def heightEncoded: Route = (path("height" / Segment) & get) { encodedSignature =>
    withExecutionContext(scheduler) {
      if (encodedSignature.length > TransactionParsers.SignatureStringLength)
        complete(InvalidSignature)
      else {
        ByteStr
          .decodeBase58(encodedSignature)
          .toOption
          .toRight(InvalidSignature)
          .flatMap(s => blockchain.heightOf(s).toRight(BlockDoesNotExist(Left(s)))) match {
          case Right(h) => complete(Json.obj("height" -> h))
          case Left(e)  => complete(e)
        }
      }
    }
  }

  /**
    * GET /blocks/height
    **/
  def height: Route = (path("height") & get) {
    withExecutionContext(scheduler) {
      complete(Json.obj("height" -> blockchain.height))
    }
  }

  /**
    * GET /blocks/at/{height}
    **/
  def at: Route = (path("at" / Segment) & get) { heightStr =>
    PositiveInt(heightStr).processRoute {
      at(_, includeTransactions = true)
    }

  }

  /**
    * GET /blocks/headers/at/{height}
    **/
  def atHeaderOnly: Route = (path("headers" / "at" / Segment) & get) { heightStr =>
    PositiveInt(heightStr).processRoute {
      at(_, includeTransactions = false)
    }
  }

  private def at(height: Int, includeTransactions: Boolean): StandardRoute = withExecutionContext(scheduler) {
    (if (includeTransactions)
       blockchain.blockAt(height).map(blockWithExtendedTxInfo)
     else {
       blockchain.blockHeaderAndSize(height).map { case (bh, s) => BlockHeader.json(bh, s) }
     }) match {
      case Some(json) => complete(json + ("height" -> JsNumber(height)))
      case None       => complete(Json.obj("status" -> "error", "details" -> "No block for this height"))
    }
  }

  /**
    * GET /blocks/seq/{from}/{to}
    **/
  def seq: Route = (path("seq" / Segment / Segment) & get) { (startStr, endStr) =>
    List(PositiveInt(startStr), PositiveInt(endStr)).processRoute {
      case Seq(start, end) =>
        seq(start, end, includeTransactions = true)
    }
  }

  /**
    * GET /blocks/seqext/{from}/{to}
    *
    * Get blocks at specified heights (with extended transaction info)
    **/
  def seqExt: Route = (path("seqext" / Segment / Segment) & get) { (startStr, endStr) =>
    List(PositiveInt(startStr), PositiveInt(endStr)).processRoute {
      case Seq(start, end) =>
        seq(start, end, includeTransactions = true, withExtendedTx = true)
    }
  }

  /**
    * GET /blocks/headers/seq/{from}/{to}
    **/
  def seqHeaderOnly: Route = (path("headers" / "seq" / Segment / Segment) & get) { (startStr, endStr) =>
    List(PositiveInt(startStr), PositiveInt(endStr)).processRoute {
      case Seq(start, end) =>
        seq(start, end, includeTransactions = false)
    }
  }

  private def seq(start: Int, end: Int, includeTransactions: Boolean, withExtendedTx: Boolean = false): StandardRoute =
    if (end >= 0 && start >= 0 && end - start >= 0 && end - start < MaxBlocksPerRequest) {
      withExecutionContext(scheduler) {
        val blocks = JsArray((start to end).flatMap { height =>
          (if (includeTransactions) {
             blockchain.blockAt(height).map(block => if (withExtendedTx) blockWithExtendedTxInfo(block) else block.json())
           } else {
             blockchain.blockHeaderAndSize(height).map { case (bh, s) => BlockHeader.json(bh, s) }
           }).map(_ + ("height" -> Json.toJson(height)))
        })
        complete(blocks)
      }
    } else if (end < start)
      complete(CustomValidationError(s"Invalid interval: end '$end' less than start '$start'"))
    else
      complete(TooBigArrayAllocation)

  /**
    * GET /blocks/last
    **/
  def last: Route = (path("last") & get)(last(includeTransactions = true))

  /**
    * GET /blocks/headers/last
    **/
  def lastHeaderOnly: Route = (path("headers" / "last") & get)(last(includeTransactions = false))

  def last(includeTransactions: Boolean): StandardRoute = withExecutionContext(scheduler) {
    complete({
      val height = blockchain.height
      (if (includeTransactions) {
         blockchain.blockAt(height).get.json()
       } else {
         val bhs = blockchain.blockHeaderAndSize(height).get
         BlockHeader.json(bhs._1, bhs._2)
       }) + ("height" -> Json.toJson(height))
    })
  }

  /**
    * GET /blocks/first
    **/
  def first: Route = (path("first") & get) {
    withExecutionContext(scheduler) {
      complete(blockchain.genesis.json() + ("height" -> Json.toJson(1)))
    }
  }

  /**
    * GET /blocks/signature/{signature}
    *
    * Get block by its signature
    **/
  def signature: Route = (path("signature" / Segment) & get) { encodedSignature =>
    withExecutionContext(scheduler) {
      if (encodedSignature.length > TransactionParsers.SignatureStringLength) complete(InvalidSignature)
      else
        ByteStr
          .decodeBase58(encodedSignature)
          .toOption
          .toRight(InvalidSignature)
          .flatMap(s => blockchain.blockById(s).toRight(BlockDoesNotExist(Left(s)))) match {
          case Right(block) => complete(block.json() + ("height" -> blockchain.heightOf(block.uniqueId).map(Json.toJson(_)).getOrElse(JsNull)))
          case Left(e)      => complete(e)
        }
    }
  }

}
